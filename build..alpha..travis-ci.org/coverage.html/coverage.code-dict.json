{"/home/travis/build/npmtest/node-npmtest-exif/test.js":"/* istanbul instrument in package npmtest_exif */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-exif/lib.npmtest_exif.js":"/* istanbul instrument in package npmtest_exif */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_exif = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_exif = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-exif/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-exif && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_exif */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_exif\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_exif.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_exif.rollup.js'] =\n            local.assetsDict['/assets.npmtest_exif.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_exif.__dirname +\n                    '/lib.npmtest_exif.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-exif/node_modules/exif/lib/exif/index.js":"module.exports = require('./ExifImage');","/home/travis/build/npmtest/node-npmtest-exif/node_modules/exif/lib/exif/ExifImage.js":"/*jslint node: true */\r\n\"use strict\";\r\n\r\nvar assert = require('assert');\r\nvar fs = require('fs');\r\nvar util = require('util');\r\nvar BufferExtender = require('./Buffer'); // bad idea\r\nvar debug = require('debug')('exif');\r\n\r\nvar DEFAULT_MAX_ENTRIES=128;\r\n\r\n/**\r\n * Represents an image with Exif information. When instantiating it you have to\r\n * provide an image and a callback function which is called once all metadata\r\n * is extracted from the image.\r\n *\r\n * Available options are:\r\n *  - image The image to get Exif data from can be either a filesystem path or\r\n *          a Buffer.\r\n *  - tiffOffsets  (boolean) an object named \"offsets\" is added to exifData \r\n *          and contains lot of offsets needed to get thumbnail and other things. \r\n *  - fixThumbnailOffset:  node-exif corrects the thumbnail offset in order to have an offset from the start of the buffer/file.\r\n *  - maxEntries: Specifies the maximum entries to be parsed\r\n *  - ifd0MaxEntries\r\n *  - ifd1MaxEntries\r\n *  - maxGpsEntries\r\n *  - maxInteroperabilityEntries\r\n *  - agfaMaxEntries \r\n *  - epsonMaxEntries\r\n *  - fujifilmMaxEntries\r\n *  - olympusMaxEntries\r\n *  - panasonicMaxEntries\r\n *  - sanyoMaxEntries\r\n *  - noPadding\r\n *\r\n * If you don't set the image field, you might call  exifImage.loadImage(image, callback) to get exif datas. \r\n *\r\n * @param options Configuration options as described above\r\n * @param callback Function to call when data is extracted or an error occurred\r\n * @return Nothing of importance, calls the specified callback function instead\r\n */\r\nfunction ExifImage (options, callback) {\r\n  if (!(this instanceof ExifImage)) {\r\n    if (typeof(options)===\"string\") {\r\n      options = {\r\n          image: options\r\n      }\r\n    }\r\n\r\n    assert(typeof(options)===\"object\", \"Invalid options object\");\r\n    \r\n    var exifImage = new ExifImage(options, function(error, data) {\r\n      if (error) {\r\n        return callback(error);\r\n      }\r\n      \r\n      callback(null, data, options.image);      \r\n    });\r\n    \r\n    return exifImage;\r\n  }\r\n\r\n  if (typeof(options)===\"string\") {\r\n    options= {\r\n        image: options\r\n    }\r\n  } else if (options instanceof Buffer) {\r\n    options= {\r\n        image: options\r\n    }\r\n  }\r\n  \r\n  var ops={};\r\n  if (options) {\r\n    for(var k in options) {\r\n      ops[k]=options[k];\r\n    }\r\n  }\r\n  this.options=ops;\r\n\r\n  // Default option values\r\n  [\"ifd0MaxEntries\", \"ifd1MaxEntries\", \"maxGpsEntries\", \"maxInteroperabilityEntries\", \"agfaMaxEntries\", \"epsonMaxEntries\", \r\n     \"fujifilmMaxEntries\", \"olympusMaxEntries\", \"panasonicMaxEntries\", \"sanyoMaxEntries\"].forEach(function(p) {\r\n       if (ops[p]===undefined) {\r\n         ops[p]=DEFAULT_MAX_ENTRIES;\r\n       }\r\n     });\r\n\r\n  this.exifData = {\r\n    image : {},                 // Information about the main image\r\n    thumbnail : {},             // Information about the thumbnail\r\n    exif : {},                  // Exif information\r\n    gps : {},                   // GPS information\r\n    interoperability: {},       // Exif Interoperability information\r\n    makernote : {}              // Makernote information\r\n  };\r\n   \r\n  this.offsets={};\r\n  if (ops.tiffOffsets) {\r\n    exifData.offsets=offsets;\r\n  }\r\n  \r\n  debug(\"New ExifImage options=\",options);\r\n\r\n  if (!ops.image) {\r\n    // If options image is not specified, the developper must call loadImage() to parse the image.\r\n//    callback(new Error('You have to provide an image, it is pretty hard to extract Exif data from nothing...'));\r\n    return;\r\n  }\r\n\r\n  if (typeof callback !== 'function') {\r\n    throw new Error('You have to provide a callback function.');\r\n  }\r\n \r\n  var self=this;\r\n  setImmediate(function() {\r\n    self.loadImage(ops.image, function (error, exifData) {\r\n      if (error) {\r\n        return callback(error);\r\n      }\r\n    \r\n      callback(null, exifData, ops.image);\r\n    });\r\n  });\r\n}\r\n\r\nExifImage.ExifImage=ExifImage;\r\n\r\nmodule.exports = ExifImage;\r\n\r\n/**\r\n * Load image and parse exifDatas\r\n *\r\n * @param [String|Buffer] image the image\r\n * @param callback a callback which is called when exif datas are parsed.\r\n * @return Nothing\r\n */\r\nExifImage.prototype.loadImage = function (image, callback) {\r\n  assert(typeof(callback)===\"function\", \"Callback must be a function\");\r\n  \r\n  var self = this;\r\n\r\n  debug(\"loadImage image=\", image);\r\n  \r\n  if (image.constructor.name === 'Buffer') {\r\n    this.processImage(\"Buffer\", image, callback);\r\n    return;\r\n  }\r\n  \r\n  if (image.constructor.name === 'String') {\r\n    fs.readFile(image, function (error, data) {\r\n      if (error) {\r\n        callback(new Error('Encountered the following error while trying to read given image: '+error));\r\n        return;\r\n      }\r\n\r\n      self.processImage(\"File: \"+image, data, callback);\r\n    });\r\n    return;\r\n  }\r\n\r\n  callback(new Error('Given image is neither a buffer nor a file, please provide one of these.'));\r\n};\r\n\r\nExifImage.prototype.processImage = function (source, data, callback) {\r\n  assert(typeof(source)===\"string\", \"Source must be a string\");\r\n  assert(typeof(callback)===\"function\", \"Callback must be a function\");\r\n  \r\n  var offset = 0;\r\n\r\n  if (data[offset++] != 0xFF || data[offset++] != 0xD8) {\r\n    var e=new Error('The given image is not a JPEG and thus unsupported right now.');\r\n    e.source=source;\r\n    e.code=\"NOT_A_JPEG\";\r\n    callback(e);\r\n    return;\r\n  }\r\n\r\n  this.imageType = 'JPEG';\r\n\r\n  while (offset < data.length) {\r\n\r\n    if (data[offset++] != 0xFF) {\r\n      break;\r\n    }\r\n\r\n    if (data[offset++] == 0xE1) {\r\n      try {\r\n        this.extractExifData(data, offset + 2, data.getShort(offset, true) - 2);\r\n\r\n      } catch (error) {\r\n        error.code=\"PARSING_ERROR\";\r\n        error.source=source;        \r\n\r\n        debug(\"Extract exif data error source=\", source, \"offset=\", offset, \"error=\",error);\r\n        \r\n        callback(error);\r\n        return;\r\n      }\r\n      \r\n      debug(\"Extract exif data success source=\", source, \"exifData=\",this.exifData);\r\n\r\n      callback(null, this.exifData);\r\n      return;\r\n    }\r\n\r\n    offset += data.getShort(offset, true);\r\n  }\r\n\r\n  var e2=new Error('No Exif segment found in the given image.');\r\n  e2.source=source;\r\n  e2.code=\"NO_EXIF_SEGMENT\";\r\n  \r\n  callback(e2);\r\n};\r\n\r\nExifImage.prototype.extractExifData = function (data, start, length) {\r\n\r\n  var exifData=this.exifData;\r\n  var tiffOffset = start + 6;\r\n  var ifdOffset, numberOfEntries;\r\n  var noPadding = (this.options.noPadding!==false);\r\n  \r\n  this.offsets.tiff=tiffOffset;\r\n\r\n  // Exif data always starts with Exif\\0\\0\r\n  if (data.toString('utf8', start, tiffOffset) != 'Exif\\0\\0') {\r\n    throw new Error('The Exif data is not valid.');\r\n  }\r\n\r\n  // After the Exif start we either have 0x4949 if the following data is\r\n  // stored in big endian or 0x4D4D if it is stored in little endian\r\n  if (data.getShort(tiffOffset) == 0x4949) {\r\n    this.isBigEndian = false;\r\n    \r\n  } else if (data.getShort(tiffOffset) == 0x4D4D) {\r\n    this.isBigEndian = true;\r\n    \r\n  } else {\r\n    throw new Error('Invalid TIFF data! Expected 0x4949 or 0x4D4D at offset '+(tiffOffset)+' but found 0x'+data[tiffOffset].toString(16).toUpperCase()+data[tiffOffset + 1].toString(16).toUpperCase()+\".\");\r\n  }\r\n\r\n  debug(\"BigEndian=\",this.isBigEndian);\r\n  \r\n  // Valid TIFF headers always have 0x002A here\r\n  if (data.getShort(tiffOffset + 2, this.isBigEndian) != 0x002A) {\r\n    var expected = (this.isBigEndian) ? '0x002A' : '0x2A00';\r\n    throw new Error('Invalid TIFF data! Expected '+expected+' at offset '+(tiffOffset + 2)+' but found 0x'+data[tiffOffset + 2].toString(16).toUpperCase()+data[tiffOffset + 3].toString(16).toUpperCase()+\".\");\r\n  }\r\n\r\n  /********************************* IFD0 **********************************/\r\n\r\n  // Offset to IFD0 which is always followed by two bytes with the amount of\r\n  // entries in this IFD\r\n  ifdOffset = tiffOffset + data.getLong(tiffOffset + 4, this.isBigEndian);\r\n  this.offsets.ifd0=ifdOffset;\r\n  \r\n  numberOfEntries = data.getShort(ifdOffset, this.isBigEndian);\r\n  if (this.options.ifd0MaxEntries) {\r\n    numberOfEntries=Math.min(numberOfEntries, this.options.ifd0MaxEntries);\r\n  }\r\n\r\n  debug(\"IFD0 ifdOffset=\",ifdOffset, \"numberOfEntries=\", numberOfEntries);\r\n\r\n  // Each IFD entry consists of 12 bytes which we loop through and extract\r\n  // the data from\r\n  for (var i = 0; i < numberOfEntries; i++) {\r\n    var exifEntry = this.extractExifEntry(data, (ifdOffset + 2 + (i * 12)), tiffOffset, this.isBigEndian, ExifImage.TAGS.exif);\r\n    if (!exifEntry) {\r\n      continue;\r\n    }\r\n    \r\n    if (exifEntry.tagId===0xEA1C && noPadding) {\r\n      continue;\r\n    }\r\n    \r\n    exifData.image[exifEntry.tagName] = exifEntry.value;\r\n  }\r\n\r\n  debug(\"IFD0 parsed\", exifData.image);\r\n\r\n  /********************************* IFD1 **********************************/\r\n\r\n  // Check if there is an offset for IFD1. If so it is always followed by two\r\n  // bytes with the amount of entries in this IFD, if not there is no IFD1\r\n  var nextIfdOffset = data.getLong(ifdOffset + 2 + (numberOfEntries * 12), this.isBigEndian)\r\n  if (nextIfdOffset != 0x00000000) {\r\n    ifdOffset = tiffOffset + nextIfdOffset;\r\n    this.offsets.ifd1=ifdOffset;\r\n    numberOfEntries = data.getShort(ifdOffset, this.isBigEndian);\r\n    if (this.options.ifd1MaxEntries) {\r\n      numberOfEntries=Math.min(numberOfEntries, this.options.ifd1MaxEntries);\r\n    }\r\n\r\n    debug(\"IFD1 ifdOffset=\",ifdOffset, \"numberOfEntries=\", numberOfEntries);\r\n\r\n    // Each IFD entry consists of 12 bytes which we loop through and extract\r\n    // the data from\r\n    for (var i = 0; i < numberOfEntries; i++) {\r\n      var exifEntry = this.extractExifEntry(data, (ifdOffset + 2 + (i * 12)), tiffOffset, this.isBigEndian, ExifImage.TAGS.exif);\r\n      if (!exifEntry) {\r\n        continue;\r\n      }\r\n\r\n      if (exifEntry.tagId===0xEA1C && noPadding) {\r\n        continue;\r\n      }\r\n                  \r\n      exifData.thumbnail[exifEntry.tagName] = exifEntry.value;\r\n    }\r\n    \r\n    if (this.options.fixThumbnailOffset) {\r\n      var thumbnailOffset=exifData.thumbnail[ExifImage.TAGS.exif[0x0201]];\r\n      if (thumbnailOffset) {\r\n        debug(\"IFD1 fix thumbnail offset, add=\",this.offsets.tiff);\r\n        \r\n        exifData.thumbnail[ExifImage.TAGS.exif[0x0201]]+=this.offsets.tiff;\r\n      }\r\n    }\r\n\r\n    debug(\"IFD1 parsed\", exifData.thumbnail);\r\n  }\r\n\r\n  /******************************* EXIF IFD ********************************/\r\n\r\n  // Look for a pointer to the Exif IFD in IFD0 and extract information from\r\n  // it if available\r\n  if (exifData.image[ExifImage.TAGS.exif[0x8769]]) {\r\n\r\n    ifdOffset = tiffOffset + exifData.image[ExifImage.TAGS.exif[0x8769]];\r\n    this.offsets.tags=ifdOffset;\r\n    \r\n    numberOfEntries = data.getShort(ifdOffset, this.isBigEndian);\r\n    if (this.options.maxEntries) {\r\n      numberOfEntries=Math.min(numberOfEntries, this.options.maxEntries);\r\n    }\r\n    \r\n    debug(\"EXIF IFD ifdOffset=\",ifdOffset, \"numberOfEntries=\", numberOfEntries);\r\n    \r\n    // Each IFD entry consists of 12 bytes which we loop through and extract\r\n    // the data from\r\n    for (var i = 0; i < numberOfEntries; i++) {\r\n      var exifEntry = this.extractExifEntry(data, (ifdOffset + 2 + (i * 12)), tiffOffset, this.isBigEndian, ExifImage.TAGS.exif);\r\n      if (!exifEntry) {\r\n        continue;\r\n      }\r\n\r\n      if (exifEntry.tagId===0xEA1C && noPadding) {\r\n        continue;\r\n      }\r\n            \r\n      exifData.exif[exifEntry.tagName] = exifEntry.value;\r\n    }\r\n\r\n    debug(\"EXIF IFD parsed\",exifData.exif);\r\n  }\r\n\r\n  /******************************** GPS IFD ********************************/\r\n\r\n  // Look for a pointer to the GPS IFD in IFD0 and extract information from\r\n  // it if available\r\n  if (exifData.image[ExifImage.TAGS.exif[0x8825]]) {\r\n\r\n    ifdOffset = tiffOffset + exifData.image[ExifImage.TAGS.exif[0x8825]];\r\n    this.offsets.gps=ifdOffset;\r\n\r\n    numberOfEntries = data.getShort(ifdOffset, this.isBigEndian);\r\n    if (this.options.maxGpsEntries) {\r\n      numberOfEntries=Math.min(numberOfEntries, this.options.maxGpsEntries);\r\n    }\r\n    \r\n    debug(\"GPS IFD ifdOffset=\", ifdOffset, \"numberOfEntries=\", numberOfEntries);\r\n\r\n    // Each IFD entry consists of 12 bytes which we loop through and extract\r\n    // the data from\r\n    for (var i = 0; i < numberOfEntries; i++) {\r\n      var exifEntry = this.extractExifEntry(data, (ifdOffset + 2 + (i * 12)), tiffOffset, this.isBigEndian, ExifImage.TAGS.gps);\r\n      if (!exifEntry) {\r\n        continue;\r\n      }\r\n\r\n      if (exifEntry.tagId===0xEA1C && noPadding) {\r\n        continue;\r\n      }\r\n      \r\n      exifData.gps[exifEntry.tagName] = exifEntry.value;\r\n    }\r\n\r\n    debug(\"GPS IFD parsed\",exifData.gps);\r\n   }\r\n\r\n  /************************* Interoperability IFD **************************/\r\n\r\n  // Look for a pointer to the interoperatbility IFD in the Exif IFD and\r\n  // extract information from it if available\r\n  if (exifData.exif[ExifImage.TAGS.exif[0xA005]]) {\r\n\r\n    ifdOffset = tiffOffset + exifData.exif[ExifImage.TAGS.exif[0xA005]];\r\n    this.offsets.interoperability=ifdOffset;\r\n    \r\n    numberOfEntries = data.getShort(ifdOffset, this.isBigEndian);\r\n    if (this.options.maxInteroperabilityEntries) {\r\n      numberOfEntries=Math.min(numberOfEntries, this.options.maxInteroperabilityEntries);\r\n    }\r\n    \r\n    debug(\"Interoperability IFD ifdOffset=\", ifdOffset, \"numberOfEntries=\", numberOfEntries);\r\n\r\n    // Each IFD entry consists of 12 bytes which we loop through and extract\r\n    // the data from\r\n    for (var i = 0; i < numberOfEntries; i++) {\r\n      var exifEntry = this.extractExifEntry(data, (ifdOffset + 2 + (i * 12)), tiffOffset, this.isBigEndian, ExifImage.TAGS.exif);\r\n      if (!exifEntry) {\r\n        break;\r\n      }\r\n\r\n      if (exifEntry.tagId===0xEA1C && noPadding) {\r\n        continue;\r\n      }\r\n            \r\n      exifData.interoperability[exifEntry.tagName] = exifEntry.value;\r\n   }\r\n\r\n    debug(\"Interoperability IFD parsed\",exifData.gps);\r\n  }\r\n\r\n  /***************************** Makernote IFD *****************************/\r\n\r\n  // Look for Makernote data in the Exif IFD, check which type of proprietary\r\n  // Makernotes the image contains, load the respective functionality and\r\n  // start the extraction\r\n  if (typeof exifData.exif[ExifImage.TAGS.exif[0x927C]] != \"undefined\") {\r\n\r\n    var type;\r\n    // Check the header to see what kind of Makernote we are dealing with\r\n    if (exifData.exif[ExifImage.TAGS.exif[0x927C]].getString(0, 7) === \"OLYMP\\x00\\x01\" || exifData.exif[ExifImage.TAGS.exif[0x927C]].getString(0, 7) === \"OLYMP\\x00\\x02\") {\r\n      type=\"olympus\"\r\n\r\n    } else if (exifData.exif[ExifImage.TAGS.exif[0x927C]].getString(0, 7) === \"AGFA \\x00\\x01\") {\r\n      type=\"agfa\";\r\n\r\n    } else if (exifData.exif[ExifImage.TAGS.exif[0x927C]].getString(0, 8) === \"EPSON\\x00\\x01\\x00\") {\r\n      type=\"epson\";\r\n\r\n    } else if (exifData.exif[ExifImage.TAGS.exif[0x927C]].getString(0, 8) === \"FUJIFILM\") {\r\n      type=\"fujifilm\";\r\n\r\n    } else if (exifData.exif[ExifImage.TAGS.exif[0x927C]].getString(0, 9) === \"Panasonic\") {\r\n      type=\"panasonic\";\r\n\r\n    } else if (exifData.exif[ExifImage.TAGS.exif[0x927C]].getString(0, 5) === \"SANYO\") {\r\n      type=\"sanyo\";\r\n    }\r\n   \r\n\r\n    debug(\"Makernote IFD ifdOffset=\", ifdOffset, \"type=\", type);\r\n\r\n    if (type) {\r\n      var extractMakernotes = require('./makernotes/'+type).extractMakernotes;\r\n\r\n      exifData.makernote = extractMakernotes.call(this, data, this.makernoteOffset, tiffOffset);\r\n      \r\n    } else {      \r\n      // Makernotes are available but the format is not recognized so\r\n      // an error message is pushed instead, this ain't the best\r\n      // solution but should do for now\r\n       exifData.makernote['error'] = 'Unable to extract Makernote information as it is in an unsupported or unrecognized format.';    \r\n    }\r\n\r\n    debug(\"Makernote IFD parsed\",exifData.makernote);\r\n  }\r\n};\r\n\r\nExifImage.prototype.extractExifEntry = function (data, entryOffset, tiffOffset, isBigEndian, tags) {\r\n\r\n  var entry = {\r\n    tag : data.slice(entryOffset, entryOffset + 2),\r\n    tagId : null,\r\n    tagName : null,\r\n    format : data.getShort(entryOffset + 2, isBigEndian),\r\n    components : data.getLong(entryOffset + 4, isBigEndian),\r\n    valueOffset: null,\r\n    value : []\r\n  }\r\n\r\n  entry.tagId = entry.tag.getShort(0, isBigEndian);\r\n\r\n  // The tagId may correspond to more then one tagName so check which\r\n  if (tags && tags[entry.tagId] && typeof tags[entry.tagId] == \"function\") {\r\n    entry.tagName = tags[entry.tagId].call(this, entry);    \r\n    if (!entry.tagName) {\r\n      return false;\r\n    }\r\n\r\n  // The tagId corresponds to exactly one tagName\r\n  } else if (tags && tags[entry.tagId]) {\r\n    entry.tagName = tags[entry.tagId];\r\n    if (entry.tagName===undefined) {\r\n      return false;\r\n    }\r\n\r\n  // The tagId is not recognized\r\n  } else {\r\n    return false;\r\n  }\r\n\r\n  switch (entry.format) {\r\n\r\n    case 0x0001: // unsigned byte, 1 byte per component\r\n      entry.valueOffset = (entry.components <= 4) ? entryOffset + 8 : data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;\r\n      for (var i = 0; i < entry.components; i++)\r\n        entry.value.push(data.getByte(entry.valueOffset + i));\r\n      break;\r\n\r\n    case 0x0002: // ascii strings, 1 byte per component\r\n      entry.valueOffset = (entry.components <= 4) ? entryOffset + 8 : data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;\r\n      entry.value = data.getString(entry.valueOffset, entry.components);\r\n      if (entry.value[entry.value.length - 1] === \"\\u0000\") // Trim null terminated strings\r\n        entry.value = entry.value.substring(0, entry.value.length - 1);\r\n      break;\r\n\r\n    case 0x0003: // unsigned short, 2 byte per component\r\n      entry.valueOffset = (entry.components <= 2) ? entryOffset + 8 : data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;\r\n      for (var i = 0; i < entry.components; i++)\r\n        entry.value.push(data.getShort(entry.valueOffset + i * 2, isBigEndian));\r\n      break;\r\n\r\n    case 0x0004: // unsigned long, 4 byte per component\r\n      entry.valueOffset = (entry.components == 1) ? entryOffset + 8 : data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;\r\n      for (var i = 0; i < entry.components; i++)\r\n        entry.value.push(data.getLong(entry.valueOffset + i * 4, isBigEndian));\r\n      break;\r\n\r\n    case 0x0005: // unsigned rational, 8 byte per component (4 byte numerator and 4 byte denominator)\r\n      entry.valueOffset = data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;\r\n      for (var i = 0; i < entry.components; i++)\r\n        entry.value.push(data.getLong(entry.valueOffset + i * 8, isBigEndian) / data.getLong(entry.valueOffset + i * 8 + 4, isBigEndian));\r\n      break;\r\n\r\n    case 0x0006: // signed byte, 1 byte per component\r\n      entry.valueOffset = (entry.components <= 4) ? entryOffset + 8 : data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;\r\n      for (var i = 0; i < entry.components; i++)\r\n        entry.value.push(data.getSignedByte(entry.valueOffset + i));\r\n      break;\r\n\r\n    case 0x0007: // undefined, 1 byte per component\r\n      entry.valueOffset = (entry.components <= 4) ? entryOffset + 8 : data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;\r\n      entry.value.push(data.slice(entry.valueOffset, entry.valueOffset + entry.components));\r\n      break;\r\n\r\n    case 0x0008: // signed short, 2 byte per component\r\n      entry.valueOffset = (entry.components <= 2) ? entryOffset + 8 : data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;\r\n      for (var i = 0; i < entry.components; i++)\r\n        entry.value.push(data.getSignedShort(entry.valueOffset + i * 2, isBigEndian));\r\n      break;\r\n\r\n    case 0x0009: // signed long, 4 byte per component\r\n      entry.valueOffset = (entry.components == 1) ? entryOffset + 8 : data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;\r\n      for (var i = 0; i < entry.components; i++)\r\n        entry.value.push(data.getSignedLong(entry.valueOffset + i * 4, isBigEndian));\r\n      break;\r\n\r\n    case 0x000A: // signed rational, 8 byte per component (4 byte numerator and 4 byte denominator)\r\n      entry.valueOffset = data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;\r\n      for (var i = 0; i < entry.components; i++)\r\n        entry.value.push(data.getSignedLong(entry.valueOffset + i * 8, isBigEndian) / data.getSignedLong(entry.valueOffset + i * 8 + 4, isBigEndian));\r\n      break;\r\n\r\n    default:\r\n      return false;\r\n\r\n  }\r\n\r\n  // If this is the Makernote tag save its offset for later use\r\n  if (entry.tagName === \"MakerNote\") {\r\n    this.offsets.makernoteOffset = entry.valueOffset;\r\n  }\r\n\r\n  // If the value array has only one element we don't need an array\r\n  if (entry.value.length == 1) {\r\n    entry.value = entry.value[0];\r\n  }\r\n\r\n  return entry;\r\n};\r\n\r\n/**\r\n * Comprehensive list of TIFF and Exif tags found on\r\n * http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/EXIF.html\r\n */\r\nExifImage.TAGS = {\r\n\r\n  // Exif tags\r\n  exif : {\r\n\r\n    0x0001 : \"InteropIndex\",\r\n    0x0002 : \"InteropVersion\",\r\n    0x000B : \"ProcessingSoftware\",\r\n    0x00FE : \"SubfileType\",\r\n    0x00FF : \"OldSubfileType\",\r\n    0x0100 : \"ImageWidth\",\r\n    0x0101 : \"ImageHeight\",\r\n    0x0102 : \"BitsPerSample\",\r\n    0x0103 : \"Compression\",\r\n    0x0106 : \"PhotometricInterpretation\",\r\n    0x0107 : \"Thresholding\",\r\n    0x0108 : \"CellWidth\",\r\n    0x0109 : \"CellLength\",\r\n    0x010A : \"FillOrder\",\r\n    0x010D : \"DocumentName\",\r\n    0x010E : \"ImageDescription\",\r\n    0x010F : \"Make\",\r\n    0x0110 : \"Model\",\r\n    0x0111 : \"StripOffsets\",\r\n    0x0112 : \"Orientation\",\r\n    0x0115 : \"SamplesPerPixel\",\r\n    0x0116 : \"RowsPerStrip\",\r\n    0x0117 : \"StripByteCounts\",\r\n    0x0118 : \"MinSampleValue\",\r\n    0x0119 : \"MaxSampleValue\",\r\n    0x011A : \"XResolution\",\r\n    0x011B : \"YResolution\",\r\n    0x011C : \"PlanarConfiguration\",\r\n    0x011D : \"PageName\",\r\n    0x011E : \"XPosition\",\r\n    0x011F : \"YPosition\",\r\n    0x0120 : \"FreeOffsets\",\r\n    0x0121 : \"FreeByteCounts\",\r\n    0x0122 : \"GrayResponseUnit\",\r\n    0x0123 : \"GrayResponseCurve\",\r\n    0x0124 : \"T4Options\",\r\n    0x0125 : \"T6Options\",\r\n    0x0128 : \"ResolutionUnit\",\r\n    0x0129 : \"PageNumber\",\r\n    0x012C : \"ColorResponseUnit\",\r\n    0x012D : \"TransferFunction\",\r\n    0x0131 : \"Software\",\r\n    0x0132 : \"ModifyDate\",\r\n    0x013B : \"Artist\",\r\n    0x013C : \"HostComputer\",\r\n    0x013D : \"Predictor\",\r\n    0x013E : \"WhitePoint\",\r\n    0x013F : \"PrimaryChromaticities\",\r\n    0x0140 : \"ColorMap\",\r\n    0x0141 : \"HalftoneHints\",\r\n    0x0142 : \"TileWidth\",\r\n    0x0143 : \"TileLength\",\r\n    0x0144 : \"TileOffsets\",\r\n    0x0145 : \"TileByteCounts\",\r\n    0x0146 : \"BadFaxLines\",\r\n    0x0147 : \"CleanFaxData\",\r\n    0x0148 : \"ConsecutiveBadFaxLines\",\r\n    0x014A : \"SubIFD\",\r\n    0x014C : \"InkSet\",\r\n    0x014D : \"InkNames\",\r\n    0x014E : \"NumberofInks\",\r\n    0x0150 : \"DotRange\",\r\n    0x0151 : \"TargetPrinter\",\r\n    0x0152 : \"ExtraSamples\",\r\n    0x0153 : \"SampleFormat\",\r\n    0x0154 : \"SMinSampleValue\",\r\n    0x0155 : \"SMaxSampleValue\",\r\n    0x0156 : \"TransferRange\",\r\n    0x0157 : \"ClipPath\",\r\n    0x0158 : \"XClipPathUnits\",\r\n    0x0159 : \"YClipPathUnits\",\r\n    0x015A : \"Indexed\",\r\n    0x015B : \"JPEGTables\",\r\n    0x015F : \"OPIProxy\",\r\n    0x0190 : \"GlobalParametersIFD\",\r\n    0x0191 : \"ProfileType\",\r\n    0x0192 : \"FaxProfile\",\r\n    0x0193 : \"CodingMethods\",\r\n    0x0194 : \"VersionYear\",\r\n    0x0195 : \"ModeNumber\",\r\n    0x01B1 : \"Decode\",\r\n    0x01B2 : \"DefaultImageColor\",\r\n    0x01B3 : \"T82Options\",\r\n    0x01B5 : \"JPEGTables\",\r\n    0x0200 : \"JPEGProc\",\r\n    0x0201 : \"ThumbnailOffset\",\r\n    0x0202 : \"ThumbnailLength\",\r\n    0x0203 : \"JPEGRestartInterval\",\r\n    0x0205 : \"JPEGLosslessPredictors\",\r\n    0x0206 : \"JPEGPointTransforms\",\r\n    0x0207 : \"JPEGQTables\",\r\n    0x0208 : \"JPEGDCTables\",\r\n    0x0209 : \"JPEGACTables\",\r\n    0x0211 : \"YCbCrCoefficients\",\r\n    0x0212 : \"YCbCrSubSampling\",\r\n    0x0213 : \"YCbCrPositioning\",\r\n    0x0214 : \"ReferenceBlackWhite\",\r\n    0x022F : \"StripRowCounts\",\r\n    0x02BC : \"ApplicationNotes\",\r\n    0x03E7 : \"USPTOMiscellaneous\",\r\n    0x1000 : \"RelatedImageFileFormat\",\r\n    0x1001 : \"RelatedImageWidth\",\r\n    0x1002 : \"RelatedImageHeight\",\r\n    0x4746 : \"Rating\",\r\n    0x4747 : \"XP_DIP_XML\",\r\n    0x4748 : \"StitchInfo\",\r\n    0x4749 : \"RatingPercent\",\r\n    0x800D : \"ImageID\",\r\n    0x80A3 : \"WangTag1\",\r\n    0x80A4 : \"WangAnnotation\",\r\n    0x80A5 : \"WangTag3\",\r\n    0x80A6 : \"WangTag4\",\r\n    0x80E3 : \"Matteing\",\r\n    0x80E4 : \"DataType\",\r\n    0x80E5 : \"ImageDepth\",\r\n    0x80E6 : \"TileDepth\",\r\n    0x827D : \"Model2\",\r\n    0x828D : \"CFARepeatPatternDim\",\r\n    0x828E : \"CFAPattern2\",\r\n    0x828F : \"BatteryLevel\",\r\n    0x8290 : \"KodakIFD\",\r\n    0x8298 : \"Copyright\",\r\n    0x829A : \"ExposureTime\",\r\n    0x829D : \"FNumber\",\r\n    0x82A5 : \"MDFileTag\",\r\n    0x82A6 : \"MDScalePixel\",\r\n    0x82A7 : \"MDColorTable\",\r\n    0x82A8 : \"MDLabName\",\r\n    0x82A9 : \"MDSampleInfo\",\r\n    0x82AA : \"MDPrepDate\",\r\n    0x82AB : \"MDPrepTime\",\r\n    0x82AC : \"MDFileUnits\",\r\n    0x830E : \"PixelScale\",\r\n    0x8335 : \"AdventScale\",\r\n    0x8336 : \"AdventRevision\",\r\n    0x835C : \"UIC1Tag\",\r\n    0x835D : \"UIC2Tag\",\r\n    0x835E : \"UIC3Tag\",\r\n    0x835F : \"UIC4Tag\",\r\n    0x83BB : \"IPTC-NAA\",\r\n    0x847E : \"IntergraphPacketData\",\r\n    0x847F : \"IntergraphFlagRegisters\",\r\n    0x8480 : \"IntergraphMatrix\",\r\n    0x8481 : \"INGRReserved\",\r\n    0x8482 : \"ModelTiePoint\",\r\n    0x84E0 : \"Site\",\r\n    0x84E1 : \"ColorSequence\",\r\n    0x84E2 : \"IT8Header\",\r\n    0x84E3 : \"RasterPadding\",\r\n    0x84E4 : \"BitsPerRunLength\",\r\n    0x84E5 : \"BitsPerExtendedRunLength\",\r\n    0x84E6 : \"ColorTable\",\r\n    0x84E7 : \"ImageColorIndicator\",\r\n    0x84E8 : \"BackgroundColorIndicator\",\r\n    0x84E9 : \"ImageColorValue\",\r\n    0x84EA : \"BackgroundColorValue\",\r\n    0x84EB : \"PixelIntensityRange\",\r\n    0x84EC : \"TransparencyIndicator\",\r\n    0x84ED : \"ColorCharacterization\",\r\n    0x84EE : \"HCUsage\",\r\n    0x84EF : \"TrapIndicator\",\r\n    0x84F0 : \"CMYKEquivalent\",\r\n    0x8546 : \"SEMInfo\",\r\n    0x8568 : \"AFCP_IPTC\",\r\n    0x85B8 : \"PixelMagicJBIGOptions\",\r\n    0x85D8 : \"ModelTransform\",\r\n    0x8602 : \"WB_GRGBLevels\",\r\n    0x8606 : \"LeafData\",\r\n    0x8649 : \"PhotoshopSettings\",\r\n    0x8769 : \"ExifOffset\",\r\n    0x8773 : \"ICC_Profile\",\r\n    0x877F : \"TIFF_FXExtensions\",\r\n    0x8780 : \"MultiProfiles\",\r\n    0x8781 : \"SharedData\",\r\n    0x8782 : \"T88Options\",\r\n    0x87AC : \"ImageLayer\",\r\n    0x87AF : \"GeoTiffDirectory\",\r\n    0x87B0 : \"GeoTiffDoubleParams\",\r\n    0x87B1 : \"GeoTiffAsciiParams\",\r\n    0x8822 : \"ExposureProgram\",\r\n    0x8824 : \"SpectralSensitivity\",\r\n    0x8825 : \"GPSInfo\",\r\n    0x8827 : \"ISO\",\r\n    0x8828 : \"Opto-ElectricConvFactor\",\r\n    0x8829 : \"Interlace\",\r\n    0x882A : \"TimeZoneOffset\",\r\n    0x882B : \"SelfTimerMode\",\r\n    0x8830 : \"SensitivityType\",\r\n    0x8831 : \"StandardOutputSensitivity\",\r\n    0x8832 : \"RecommendedExposureIndex\",\r\n    0x8833 : \"ISOSpeed\",\r\n    0x8834 : \"ISOSpeedLatitudeyyy\",\r\n    0x8835 : \"ISOSpeedLatitudezzz\",\r\n    0x885C : \"FaxRecvParams\",\r\n    0x885D : \"FaxSubAddress\",\r\n    0x885E : \"FaxRecvTime\",\r\n    0x888A : \"LeafSubIFD\",\r\n    0x9000 : \"ExifVersion\",\r\n    0x9003 : \"DateTimeOriginal\",\r\n    0x9004 : \"CreateDate\",\r\n    0x9101 : \"ComponentsConfiguration\",\r\n    0x9102 : \"CompressedBitsPerPixel\",\r\n    0x9201 : \"ShutterSpeedValue\",\r\n    0x9202 : \"ApertureValue\",\r\n    0x9203 : \"BrightnessValue\",\r\n    0x9204 : \"ExposureCompensation\",\r\n    0x9205 : \"MaxApertureValue\",\r\n    0x9206 : \"SubjectDistance\",\r\n    0x9207 : \"MeteringMode\",\r\n    0x9208 : \"LightSource\",\r\n    0x9209 : \"Flash\",\r\n    0x920A : \"FocalLength\",\r\n    0x920B : \"FlashEnergy\",\r\n    0x920C : \"SpatialFrequencyResponse\",\r\n    0x920D : \"Noise\",\r\n    0x920E : \"FocalPlaneXResolution\",\r\n    0x920F : \"FocalPlaneYResolution\",\r\n    0x9210 : \"FocalPlaneResolutionUnit\",\r\n    0x9211 : \"ImageNumber\",\r\n    0x9212 : \"SecurityClassification\",\r\n    0x9213 : \"ImageHistory\",\r\n    0x9214 : \"SubjectArea\",\r\n    0x9215 : \"ExposureIndex\",\r\n    0x9216 : \"TIFF-EPStandardID\",\r\n    0x9217 : \"SensingMethod\",\r\n    0x923A : \"CIP3DataFile\",\r\n    0x923B : \"CIP3Sheet\",\r\n    0x923C : \"CIP3Side\",\r\n    0x923F : \"StoNits\",\r\n    0x927C : \"MakerNote\",\r\n    0x9286 : \"UserComment\",\r\n    0x9290 : \"SubSecTime\",\r\n    0x9291 : \"SubSecTimeOriginal\",\r\n    0x9292 : \"SubSecTimeDigitized\",\r\n    0x932F : \"MSDocumentText\",\r\n    0x9330 : \"MSPropertySetStorage\",\r\n    0x9331 : \"MSDocumentTextPosition\",\r\n    0x935C : \"ImageSourceData\",\r\n    0x9C9B : \"XPTitle\",\r\n    0x9C9C : \"XPComment\",\r\n    0x9C9D : \"XPAuthor\",\r\n    0x9C9E : \"XPKeywords\",\r\n    0x9C9F : \"XPSubject\",\r\n    0xA000 : \"FlashpixVersion\",\r\n    0xA001 : \"ColorSpace\",\r\n    0xA002 : \"ExifImageWidth\",\r\n    0xA003 : \"ExifImageHeight\",\r\n    0xA004 : \"RelatedSoundFile\",\r\n    0xA005 : \"InteropOffset\",\r\n    0xA20B : \"FlashEnergy\",\r\n    0xA20C : \"SpatialFrequencyResponse\",\r\n    0xA20D : \"Noise\",\r\n    0xA20E : \"FocalPlaneXResolution\",\r\n    0xA20F : \"FocalPlaneYResolution\",\r\n    0xA210 : \"FocalPlaneResolutionUnit\",\r\n    0xA211 : \"ImageNumber\",\r\n    0xA212 : \"SecurityClassification\",\r\n    0xA213 : \"ImageHistory\",\r\n    0xA214 : \"SubjectLocation\",\r\n    0xA215 : \"ExposureIndex\",\r\n    0xA216 : \"TIFF-EPStandardID\",\r\n    0xA217 : \"SensingMethod\",\r\n    0xA300 : \"FileSource\",\r\n    0xA301 : \"SceneType\",\r\n    0xA302 : \"CFAPattern\",\r\n    0xA401 : \"CustomRendered\",\r\n    0xA402 : \"ExposureMode\",\r\n    0xA403 : \"WhiteBalance\",\r\n    0xA404 : \"DigitalZoomRatio\",\r\n    0xA405 : \"FocalLengthIn35mmFormat\",\r\n    0xA406 : \"SceneCaptureType\",\r\n    0xA407 : \"GainControl\",\r\n    0xA408 : \"Contrast\",\r\n    0xA409 : \"Saturation\",\r\n    0xA40A : \"Sharpness\",\r\n    0xA40B : \"DeviceSettingDescription\",\r\n    0xA40C : \"SubjectDistanceRange\",\r\n    0xA420 : \"ImageUniqueID\",\r\n    0xA430 : \"OwnerName\",\r\n    0xA431 : \"SerialNumber\",\r\n    0xA432 : \"LensInfo\",\r\n    0xA433 : \"LensMake\",\r\n    0xA434 : \"LensModel\",\r\n    0xA435 : \"LensSerialNumber\",\r\n    0xA480 : \"GDALMetadata\",\r\n    0xA481 : \"GDALNoData\",\r\n    0xA500 : \"Gamma\",\r\n    0xAFC0 : \"ExpandSoftware\",\r\n    0xAFC1 : \"ExpandLens\",\r\n    0xAFC2 : \"ExpandFilm\",\r\n    0xAFC3 : \"ExpandFilterLens\",\r\n    0xAFC4 : \"ExpandScanner\",\r\n    0xAFC5 : \"ExpandFlashLamp\",\r\n    0xBC01 : \"PixelFormat\",\r\n    0xBC02 : \"Transformation\",\r\n    0xBC03 : \"Uncompressed\",\r\n    0xBC04 : \"ImageType\",\r\n    0xBC80 : \"ImageWidth\",\r\n    0xBC81 : \"ImageHeight\",\r\n    0xBC82 : \"WidthResolution\",\r\n    0xBC83 : \"HeightResolution\",\r\n    0xBCC0 : \"ImageOffset\",\r\n    0xBCC1 : \"ImageByteCount\",\r\n    0xBCC2 : \"AlphaOffset\",\r\n    0xBCC3 : \"AlphaByteCount\",\r\n    0xBCC4 : \"ImageDataDiscard\",\r\n    0xBCC5 : \"AlphaDataDiscard\",\r\n    0xC427 : \"OceScanjobDesc\",\r\n    0xC428 : \"OceApplicationSelector\",\r\n    0xC429 : \"OceIDNumber\",\r\n    0xC42A : \"OceImageLogic\",\r\n    0xC44F : \"Annotations\",\r\n    0xC4A5 : \"PrintIM\",\r\n    0xC580 : \"USPTOOriginalContentType\",\r\n    0xC612 : \"DNGVersion\",\r\n    0xC613 : \"DNGBackwardVersion\",\r\n    0xC614 : \"UniqueCameraModel\",\r\n    0xC615 : \"LocalizedCameraModel\",\r\n    0xC616 : \"CFAPlaneColor\",\r\n    0xC617 : \"CFALayout\",\r\n    0xC618 : \"LinearizationTable\",\r\n    0xC619 : \"BlackLevelRepeatDim\",\r\n    0xC61A : \"BlackLevel\",\r\n    0xC61B : \"BlackLevelDeltaH\",\r\n    0xC61C : \"BlackLevelDeltaV\",\r\n    0xC61D : \"WhiteLevel\",\r\n    0xC61E : \"DefaultScale\",\r\n    0xC61F : \"DefaultCropOrigin\",\r\n    0xC620 : \"DefaultCropSize\",\r\n    0xC621 : \"ColorMatrix1\",\r\n    0xC622 : \"ColorMatrix2\",\r\n    0xC623 : \"CameraCalibration1\",\r\n    0xC624 : \"CameraCalibration2\",\r\n    0xC625 : \"ReductionMatrix1\",\r\n    0xC626 : \"ReductionMatrix2\",\r\n    0xC627 : \"AnalogBalance\",\r\n    0xC628 : \"AsShotNeutral\",\r\n    0xC629 : \"AsShotWhiteXY\",\r\n    0xC62A : \"BaselineExposure\",\r\n    0xC62B : \"BaselineNoise\",\r\n    0xC62C : \"BaselineSharpness\",\r\n    0xC62D : \"BayerGreenSplit\",\r\n    0xC62E : \"LinearResponseLimit\",\r\n    0xC62F : \"CameraSerialNumber\",\r\n    0xC630 : \"DNGLensInfo\",\r\n    0xC631 : \"ChromaBlurRadius\",\r\n    0xC632 : \"AntiAliasStrength\",\r\n    0xC633 : \"ShadowScale\",\r\n    0xC634 : \"DNGPrivateData\",\r\n    0xC635 : \"MakerNoteSafety\",\r\n    0xC640 : \"RawImageSegmentation\",\r\n    0xC65A : \"CalibrationIlluminant1\",\r\n    0xC65B : \"CalibrationIlluminant2\",\r\n    0xC65C : \"BestQualityScale\",\r\n    0xC65D : \"RawDataUniqueID\",\r\n    0xC660 : \"AliasLayerMetadata\",\r\n    0xC68B : \"OriginalRawFileName\",\r\n    0xC68C : \"OriginalRawFileData\",\r\n    0xC68D : \"ActiveArea\",\r\n    0xC68E : \"MaskedAreas\",\r\n    0xC68F : \"AsShotICCProfile\",\r\n    0xC690 : \"AsShotPreProfileMatrix\",\r\n    0xC691 : \"CurrentICCProfile\",\r\n    0xC692 : \"CurrentPreProfileMatrix\",\r\n    0xC6BF : \"ColorimetricReference\",\r\n    0xC6D2 : \"PanasonicTitle\",\r\n    0xC6D3 : \"PanasonicTitle2\",\r\n    0xC6F3 : \"CameraCalibrationSig\",\r\n    0xC6F4 : \"ProfileCalibrationSig\",\r\n    0xC6F5 : \"ProfileIFD\",\r\n    0xC6F6 : \"AsShotProfileName\",\r\n    0xC6F7 : \"NoiseReductionApplied\",\r\n    0xC6F8 : \"ProfileName\",\r\n    0xC6F9 : \"ProfileHueSatMapDims\",\r\n    0xC6FA : \"ProfileHueSatMapData1\",\r\n    0xC6FB : \"ProfileHueSatMapData2\",\r\n    0xC6FC : \"ProfileToneCurve\",\r\n    0xC6FD : \"ProfileEmbedPolicy\",\r\n    0xC6FE : \"ProfileCopyright\",\r\n    0xC714 : \"ForwardMatrix1\",\r\n    0xC715 : \"ForwardMatrix2\",\r\n    0xC716 : \"PreviewApplicationName\",\r\n    0xC717 : \"PreviewApplicationVersion\",\r\n    0xC718 : \"PreviewSettingsName\",\r\n    0xC719 : \"PreviewSettingsDigest\",\r\n    0xC71A : \"PreviewColorSpace\",\r\n    0xC71B : \"PreviewDateTime\",\r\n    0xC71C : \"RawImageDigest\",\r\n    0xC71D : \"OriginalRawFileDigest\",\r\n    0xC71E : \"SubTileBlockSize\",\r\n    0xC71F : \"RowInterleaveFactor\",\r\n    0xC725 : \"ProfileLookTableDims\",\r\n    0xC726 : \"ProfileLookTableData\",\r\n    0xC740 : \"OpcodeList1\",\r\n    0xC741 : \"OpcodeList2\",\r\n    0xC74E : \"OpcodeList3\",\r\n    0xC761 : \"NoiseProfile\",\r\n    0xC763 : \"TimeCodes\",\r\n    0xC764 : \"FrameRate\",\r\n    0xC772 : \"TStop\",\r\n    0xC789 : \"ReelName\",\r\n    0xC791 : \"OriginalDefaultFinalSize\",\r\n    0xC792 : \"OriginalBestQualitySize\",\r\n    0xC793 : \"OriginalDefaultCropSize\",\r\n    0xC7A1 : \"CameraLabel\",\r\n    0xC7A3 : \"ProfileHueSatMapEncoding\",\r\n    0xC7A4 : \"ProfileLookTableEncoding\",\r\n    0xC7A5 : \"BaselineExposureOffset\",\r\n    0xC7A6 : \"DefaultBlackRender\",\r\n    0xC7A7 : \"NewRawImageDigest\",\r\n    0xC7A8 : \"RawToPreviewGain\",\r\n    0xC7B5 : \"DefaultUserCrop\",\r\n    0xEA1C : \"Padding\",\r\n    0xEA1D : \"OffsetSchema\",\r\n    0xFDE8 : \"OwnerName\",\r\n    0xFDE9 : \"SerialNumber\",\r\n    0xFDEA : \"Lens\",\r\n    0xFE00 : \"KDC_IFD\",\r\n    0xFE4C : \"RawFile\",\r\n    0xFE4D : \"Converter\",\r\n    0xFE4E : \"WhiteBalance\",\r\n    0xFE51 : \"Exposure\",\r\n    0xFE52 : \"Shadows\",\r\n    0xFE53 : \"Brightness\",\r\n    0xFE54 : \"Contrast\",\r\n    0xFE55 : \"Saturation\",\r\n    0xFE56 : \"Sharpness\",\r\n    0xFE57 : \"Smoothness\",\r\n    0xFE58 : \"MoireFilter\"\r\n\r\n  },\r\n\r\n  // GPS Tags\r\n  gps : {\r\n\r\n    0x0000 : 'GPSVersionID',\r\n    0x0001 : 'GPSLatitudeRef',\r\n    0x0002 : 'GPSLatitude',\r\n    0x0003 : 'GPSLongitudeRef',\r\n    0x0004 : 'GPSLongitude',\r\n    0x0005 : 'GPSAltitudeRef',\r\n    0x0006 : 'GPSAltitude',\r\n    0x0007 : 'GPSTimeStamp',\r\n    0x0008 : 'GPSSatellites',\r\n    0x0009 : 'GPSStatus',\r\n    0x000A : 'GPSMeasureMode',\r\n    0x000B : 'GPSDOP',\r\n    0x000C : 'GPSSpeedRef',\r\n    0x000D : 'GPSSpeed',\r\n    0x000E : 'GPSTrackRef',\r\n    0x000F : 'GPSTrack',\r\n    0x0010 : 'GPSImgDirectionRef',\r\n    0x0011 : 'GPSImgDirection',\r\n    0x0012 : 'GPSMapDatum',\r\n    0x0013 : 'GPSDestLatitudeRef',\r\n    0x0014 : 'GPSDestLatitude',\r\n    0x0015 : 'GPSDestLongitudeRef',\r\n    0x0016 : 'GPSDestLongitude',\r\n    0x0017 : 'GPSDestBearingRef',\r\n    0x0018 : 'GPSDestBearing',\r\n    0x0019 : 'GPSDestDistanceRef',\r\n    0x001A : 'GPSDestDistance',\r\n    0x001B : 'GPSProcessingMethod',\r\n    0x001C : 'GPSAreaInformation',\r\n    0x001D : 'GPSDateStamp',\r\n    0x001E : 'GPSDifferential',\r\n    0x001F : 'GPSHPositioningError'\r\n\r\n  }\r\n\r\n};","/home/travis/build/npmtest/node-npmtest-exif/node_modules/exif/lib/exif/Buffer.js":"//\r\n// A couple of methods that make working with buffers more easy.\r\n//\r\n\r\nBuffer.prototype.getByte = function (offset) {\r\n  return this[offset];\r\n};\r\n\r\nBuffer.prototype.getSignedByte = function (offset) {\r\n  return (this[offset] > 127) ? this[offset] - 256 : this[offset];\r\n};\r\n\r\nBuffer.prototype.getShort = function (offset, bigEndian) {\r\n  var shortVal = (bigEndian) ? (this[offset] << 8) + this[offset + 1] : (this[offset + 1] << 8) + this[offset];\r\n  return (shortVal < 0) ? shortVal + 65536 : shortVal;\r\n};\r\n\r\nBuffer.prototype.getSignedShort = function (offset, bigEndian) {\r\n  var shortVal = (bigEndian) ? (this[offset] << 8) + this[offset + 1] : (this[offset + 1] << 8) + this[offset];\r\n  return (shortVal > 32767) ? shortVal - 65536 : shortVal;\r\n};\r\n\r\nBuffer.prototype.getLong = function (offset, bigEndian) {\r\n  var longVal = (bigEndian) ? (((((this[offset] << 8) + this[offset + 1]) << 8) + this[offset + 2]) << 8) + this[offset + 3] : (((((this[offset + 3] << 8) + this[offset + 2]) << 8) + this[offset + 1]) << 8) + this[offset];\r\n  return (longVal < 0) ? longVal + 4294967296 : longVal;\r\n};\r\n\r\nBuffer.prototype.getSignedLong = function (offset, bigEndian) {\r\n  var longVal = (bigEndian) ? (((((this[offset] << 8) + this[offset + 1]) << 8) + this[offset + 2]) << 8) + this[offset + 3] : (((((this[offset + 3] << 8) + this[offset + 2]) << 8) + this[offset + 1]) << 8) + this[offset];\r\n  return (longVal > 2147483647) ? longVal - 4294967296 : longVal;\r\n};\r\n\r\nBuffer.prototype.getString = function (offset, length) {\r\n  var string = [];\r\n  for (var i = offset; i < offset + length; i++) {\r\n    string.push(String.fromCharCode(this[i]));\r\n  }\r\n  return string.join('');\r\n};"}